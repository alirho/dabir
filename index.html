<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>دبیر</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap');

        body {
            font-family: 'Vazirmatn', sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 2rem;
            color: #333;
        }

        #editor {
            background-color: white;
            max-width: 800px;
            min-height: 90vh;
            margin: 0 auto;
            padding: 50px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
            outline: none;
            font-size: 18px;
            line-height: 1.8;
            white-space: pre-wrap;
        }

        #editor h1,
        #editor h2,
        #editor h3,
        #editor h4 {
            margin: 1.5em 0 0.5em;
            line-height: 1.3;
            font-weight: 700;
        }

        #editor h1 {
            font-size: 2em;
        }

        #editor h2 {
            font-size: 1.75em;
        }

        #editor h3 {
            font-size: 1.5em;
        }

        #editor h4 {
            font-size: 1.25em;
        }

        #editor blockquote {
            border-right: 4px solid #e0e0e0;
            padding-right: 1.5em;
            margin: 1em 0;
            color: #555;
            background-color: #f9f9f9;
        }

        #editor strong {
            font-weight: 700;
        }

        #editor em {
            font-style: italic;
        }

        #editor del {
            text-decoration: line-through;
            color: #888;
        }

        #editor a {
            color: #007bff;
            text-decoration: none;
            cursor: pointer;
        }

        #editor a:hover {
            text-decoration: underline;
        }

        #editor ul {
            padding-right: 2em;
        }

        #editor ol,
        #editor ul {
            margin: 1em 0;
        }

        #editor li {
            padding-right: 0.5em;
            margin-bottom: 0.5em;
        }

        /* استایل‌های جدید برای لیست‌های تودرتو */
        #editor ul ul {
            list-style-type: circle;
        }

        #editor ul ul ul {
            list-style-type: square;
        }

        #editor ul ul ul ul {
            list-style-type: disc;
        }
        
        /* بازنویسی کامل استایل لیست‌های مرتب برای فاصله‌گذاری یکسان */
        #editor ol {
            list-style-type: none;
            counter-reset: item;
            padding-right: 0;
        }

        #editor ol > li {
            display: table;
            counter-increment: item;
            padding-right: 0; /* Let the ::before handle all spacing */
        }

        #editor ol > li::before {
            content: "\200e" counters(item, ".") ".";
            display: table-cell;
            white-space: nowrap;
            width: 1%;
            padding-left: 0.8em; 
            vertical-align: top;
        }


        #editor ul ul,
        #editor ol ol,
        #editor ol ul,
        #editor ul ol {
            margin-right: -20px;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        #editor ul.checklist {
            list-style-type: none;
            padding-right: 0;
        }
        
        #editor li.checklist-item {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
        }

        /* Force nested checklist to wrap to new line and indent */
        #editor li.checklist-item > ul.checklist {
            flex-basis: 100%;
            width: 100%;
            padding-right: 2.5em;
        }

        #editor li.checklist-item input[type="checkbox"] {
            margin-left: 0.75em;
            cursor: pointer;
        }

        #editor li.checklist-item.checked {
            text-decoration: line-through;
            color: #888;
        }

        #editor code {
            font-family: 'Source Code Pro', monospace;
            background-color: #f0f0f0;
            padding: 0.1em 0.4em;
            border-radius: 4px;
            font-size: 0.9em;
        }

        #editor pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 1em;
            border-radius: 8px;
            overflow-x: auto;
            white-space: pre-wrap;
        }

        #editor pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            font-size: 1em;
            white-space: inherit;
        }

        #editor table {
            border-collapse: collapse;
            width: 100%;
            margin: 1.5em 0;
            table-layout: fixed; /* عرض ستون‌ها ثابت می‌ماند */
        }

        #editor th,
        #editor td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: right;
            overflow-wrap: break-word; /* متن طولانی شکسته می‌شود */
        }

        #editor th {
            background-color: #f7f7f7;
            font-weight: 700;
        }

        #editor tr:nth-child(even) {
            background-color: #fcfcfc;
        }

        #editor:empty:before {
            content: attr(data-placeholder);
            color: #999;
            pointer-events: none;
        }

        /* ۱. استایل‌های جدید برای عکس و زیرنویس */
        #editor figure {
            margin: 1.5em 0;
            text-align: center;
        }

        #editor figure img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        #editor figure figcaption {
            margin-top: 0.8em;
            font-size: 0.9em;
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="editor" contenteditable="true" data-placeholder="اینجا بنویسید..."></div>

    <script>
        const editor = document.getElementById('editor');
        let activeRawNode = null;
        let ignoreSelectionChange = false;

        window.addEventListener('load', () => {
            const savedContent = localStorage.getItem('mySmartNote');
            if (savedContent) {
                editor.innerHTML = savedContent;
            }
        });
        editor.addEventListener('input', () => {
            if (!activeRawNode) {
                localStorage.setItem('mySmartNote', editor.innerHTML);
            }
        });

        function elementToRawMarkdown(el) {
            const text = el.textContent;
            switch (el.tagName) {
                case 'STRONG': return `**${text}**`;
                case 'EM':     return `*${text}*`;
                case 'DEL':    return `~~${text}~~`;
                case 'CODE':   return `\`${text}\``;
                case 'A':      return `[${text}](${el.getAttribute('href')})`;
                case 'H1':     return `# ${text}`;
                case 'H2':     return `## ${text}`;
                case 'H3':     return `### ${text}`;
                case 'H4':     return `#### ${text}`;
                case 'FIGURE': {
                    const img = el.querySelector('img');
                    const figcaption = el.querySelector('figcaption');
                    const alt = figcaption ? figcaption.textContent : (img ? img.alt : '');
                    const src = img ? img.src : '';
                    return `![${alt}](${src})`;
                }
                case 'BLOCKQUOTE': {
                    return Array.from(el.children)
                                .map(child => `> ${child.textContent}`)
                                .join('\n');
                }
                default:       return text;
            }
        }

        function renderRawMarkdownNode(textNode) {
            if (!textNode || textNode.nodeType !== Node.TEXT_NODE || !textNode.parentElement) return null;
    
            const text = textNode.textContent;
            const parent = textNode.parentElement;
            let match;
            let newNode = null;
            let isBlock = false;

            // Block-level elements are handled when the parent is a DIV directly under the editor
            if (parent.tagName === 'DIV' && parent.parentElement === editor) {
                if ((match = text.match(/^(#{1,4}) ([^\n]+?)$/))) {
                    const level = match[1].length;
                    newNode = document.createElement(`h${level}`);
                    newNode.textContent = match[2];
                    isBlock = true;
                } else if ((match = text.match(/^!\[([^\]]*)\]\(([^)]+)\)$/))) {
                    const altText = match[1];
                    const imageUrl = match[2];
                    newNode = document.createElement('figure');
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.alt = altText;
                    newNode.appendChild(img);
                    if (altText) {
                        const figcaption = document.createElement('figcaption');
                        figcaption.textContent = altText;
                        newNode.appendChild(figcaption);
                    }
                    isBlock = true;
                } else if (text.startsWith('> ')) {
                    const lines = text.split('\n').filter(line => line.startsWith('> '));
                    if (lines.length > 0 && lines.every(line => line.startsWith('> '))) {
                        newNode = document.createElement('blockquote');
                        lines.forEach(line => {
                            const lineDiv = document.createElement('div');
                            const content = line.substring(2);
                            if (content) {
                                lineDiv.textContent = content;
                            } else {
                                lineDiv.appendChild(document.createElement('br'));
                            }
                            newNode.appendChild(lineDiv);
                        });
                        isBlock = true;
                    }
                }
            }
            
            if (!isBlock) { // Check for inline elements if no block element was matched
                if ((match = text.match(/^\*\*([^*]+)\*\*$/))) {
                    newNode = document.createElement('strong');
                    newNode.textContent = match[1];
                } else if ((match = text.match(/^\*([^*]+)\*$/))) {
                    newNode = document.createElement('em');
                    newNode.textContent = match[1];
                } else if ((match = text.match(/^~~([^~]+)~~$/))) {
                    newNode = document.createElement('del');
                    newNode.textContent = match[1];
                } else if ((match = text.match(/^`([^`]+)`$/))) {
                    newNode = document.createElement('code');
                    newNode.textContent = match[1];
                } else if ((match = text.match(/^\[([^\]]+)\]\(([^)]+)\)$/))) {
                    newNode = document.createElement('a');
                    newNode.textContent = match[1];
                    newNode.href = match[2];
                    newNode.target = '_blank';
                }
            }

            if (newNode) {
                const selection = window.getSelection();
                const range = document.createRange();

                if (isBlock) {
                    parent.replaceWith(newNode);
                    moveCursorToEnd(newNode, selection);
                } else {
                    textNode.replaceWith(newNode);
                    range.setStartAfter(newNode);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
                
                localStorage.setItem('mySmartNote', editor.innerHTML);
                return newNode;
            }
            return null;
        }

        function revealMarkdown(element) {
            if (activeRawNode) {
                renderRawMarkdownNode(activeRawNode);
            }

            const rawText = elementToRawMarkdown(element);
            const textNode = document.createTextNode(rawText);
            
            const isBlock = ['H1', 'H2', 'H3', 'H4', 'FIGURE', 'BLOCKQUOTE'].includes(element.tagName);
            if (isBlock) {
                const newDiv = document.createElement('div');
                newDiv.appendChild(textNode);
                element.replaceWith(newDiv);
            } else {
                element.replaceWith(textNode);
            }
            activeRawNode = textNode;

            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(textNode);
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
        }

        function renderActiveNode() {
            if (!activeRawNode) return;
            
            ignoreSelectionChange = true;
            
            const nodeToRender = activeRawNode;
            activeRawNode = null; 
            renderRawMarkdownNode(nodeToRender);

            setTimeout(() => { ignoreSelectionChange = false; }, 0);
        }

        document.addEventListener('selectionchange', () => {
            if (ignoreSelectionChange) return;

            const selection = window.getSelection();
            if (!selection || !selection.rangeCount) return;
            const anchorNode = selection.anchorNode;

            if (!editor.contains(anchorNode)) {
                if (activeRawNode) renderActiveNode();
                return;
            }

            const parentElement = anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;

            if (activeRawNode && anchorNode !== activeRawNode) {
                renderActiveNode();
                return; 
            }

            if (selection.isCollapsed && !activeRawNode) {
                const elementToReveal = parentElement.closest('strong, em, del, code, a, h1, h2, h3, h4, figure, blockquote');
                if (elementToReveal && !elementToReveal.closest('pre, table, li')) {
                    ignoreSelectionChange = true;
                    revealMarkdown(elementToReveal);
                    setTimeout(() => { ignoreSelectionChange = false; }, 0);
                }
            }
        });

        editor.addEventListener('click', (e) => {
            const target = e.target;
            
            const link = target.closest('a');
            if (link && (e.metaKey || e.ctrlKey)) {
                e.preventDefault();
                window.open(link.href, '_blank');
                return;
            }
            
            if (target.tagName === 'INPUT' && target.type === 'checkbox') {
                const checklistItem = target.closest('li.checklist-item');
                if (checklistItem) {
                    setTimeout(() => {
                        checklistItem.classList.toggle('checked', target.checked);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                    }, 0);
                }
            }
        });

        editor.addEventListener('keydown', (e) => {
            if (activeRawNode && e.key === 'Escape') {
                e.preventDefault();
                renderActiveNode();
                return;
            }
            
            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            const range = selection.getRangeAt(0);
            const parentElement = selection.anchorNode.nodeType === 3 ?
                selection.anchorNode.parentElement :
                selection.anchorNode;

            const listItem = parentElement.closest('li');
            if (listItem && e.key === 'Tab') {
                e.preventDefault();
                if (e.shiftKey) {
                    const parentList = listItem.parentElement;
                    const parentLi = parentList.parentElement.closest('li');
                    if (parentLi) {
                        parentLi.after(listItem);
                        if (parentList.children.length === 0) {
                            parentList.remove();
                        }
                        moveCursorToEnd(listItem, selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                    }
                } else {
                    const previousLi = listItem.previousElementSibling;
                    if (previousLi) {
                        let depth = 0;
                        let el = listItem;
                        while ((el = el.closest('ul, ol')?.parentElement?.closest('li'))) {
                            depth++;
                        }
                        
                        const parentListTag = listItem.parentElement.tagName;
                        const maxDepth = parentListTag === 'OL' ? 3 : 4;

                        if (depth < maxDepth) {
                            let sublist = previousLi.querySelector('ul, ol');
                            if (!sublist) {
                                sublist = document.createElement(parentListTag);
                                if (listItem.classList.contains('checklist-item')) {
                                    sublist.classList.add('checklist');
                                }
                                previousLi.appendChild(sublist);
                            }
                            sublist.appendChild(listItem);
                            moveCursorToEnd(listItem, selection);
                            localStorage.setItem('mySmartNote', editor.innerHTML);
                        }
                    }
                }
                return;
            }
            
            const checklistItem = parentElement.closest('li.checklist-item');
            if (e.key === 'Backspace' && selection.isCollapsed && checklistItem && checklistItem.textContent.trim() === '') {
                if ((range.startContainer === checklistItem && range.startOffset <= 1) || (range.startContainer.parentElement === checklistItem && range.startOffset === 0)) {
                    e.preventDefault();
                    
                    const parentList = checklistItem.parentElement;
                    const previousItem = checklistItem.previousElementSibling;

                    if (previousItem) {
                        checklistItem.remove();
                        moveCursorToEnd(previousItem, selection);
                    } else {
                        const newPara = document.createElement('div');
                        newPara.innerHTML = '<br>';
                        
                        const parentLi = parentList.parentElement.closest('li');
                        if(parentLi) {
                            parentList.remove();
                            moveCursorToEnd(parentLi, selection);
                        } else {
                            parentList.before(newPara);
                             if (parentList.children.length === 1) {
                                parentList.remove();
                            }
                            checklistItem.remove();
                            moveCursorToEnd(newPara, selection);
                        }
                    }
                    
                    localStorage.setItem('mySmartNote', editor.innerHTML);
                    return;
                }
            }


            const tableCell = parentElement.closest('th, td');
            if (tableCell) {
                const currentRow = tableCell.parentElement;

                if (e.key === 'Backspace' &&
                    selection.isCollapsed &&
                    range.startOffset === 0 &&
                    tableCell === currentRow.cells[0]) {

                    const isRowEmpty = Array.from(currentRow.cells).every(cell => cell.textContent.trim() === '');

                    if (isRowEmpty) {
                        e.preventDefault();
                        
                        const table = tableCell.closest('table');
                        const isHeaderRow = currentRow.parentElement.tagName === 'THEAD';

                        const previousRow = currentRow.previousElementSibling;
                        const nextRow = currentRow.nextElementSibling;
                        const firstBodyRow = table.tBodies[0]?.rows[0];
                        const lastHeaderRow = table.tHead?.rows[table.tHead.rows.length - 1];

                        const parentContainer = currentRow.parentElement;
                        currentRow.remove();
                        if (parentContainer.rows.length === 0) {
                            parentContainer.remove();
                        }

                        if (table.rows.length === 0) {
                            const newPara = document.createElement('div');
                            newPara.innerHTML = '<br>';
                            table.after(newPara);
                            table.remove();
                            moveCursorToEnd(newPara, selection);
                        } else if (isHeaderRow) {
                            if (firstBodyRow) {
                                moveCursorToEnd(firstBodyRow.cells[0], selection);
                            }
                        } else { 
                            if (previousRow) {
                                moveCursorToEnd(previousRow.cells[previousRow.cells.length - 1], selection);
                            } else if (nextRow) {
                                moveCursorToEnd(nextRow.cells[0], selection);
                            } else if (lastHeaderRow) {
                                moveCursorToEnd(lastHeaderRow.cells[lastHeaderRow.cells.length - 1], selection);
                            }
                        }
                        
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                }

                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (currentRow.parentElement.tagName === 'TBODY' &&
                        !currentRow.nextElementSibling &&
                        Array.from(currentRow.cells).every(cell => cell.textContent.trim() === '')) {
                        const table = tableCell.closest('table');
                        const newPara = document.createElement('div');
                        newPara.innerHTML = '<br>';
                        table.after(newPara);
                        currentRow.remove();
                        moveCursorToEnd(newPara, selection);
                    } else {
                        const table = tableCell.closest('table');
                        const alignments = JSON.parse(table.dataset.alignments || '[]');
                        const newRow = currentRow.parentElement.insertRow(currentRow.rowIndex);
                        for (let i = 0; i < currentRow.cells.length; i++) {
                            const cell = newRow.insertCell(i);
                            cell.appendChild(document.createElement('br'));
                            if (alignments[i]) {
                                cell.style.textAlign = alignments[i];
                            }
                        }
                        moveCursorToEnd(newRow.cells[0], selection);
                    }
                    localStorage.setItem('mySmartNote', editor.innerHTML);
                    return;
                }

                if (e.key === 'Tab') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        let prevCell = tableCell.previousElementSibling;
                        if (prevCell) {
                            moveCursorToEnd(prevCell, selection);
                        } else {
                            const prevRow = currentRow.previousElementSibling;
                            if (prevRow) {
                                moveCursorToEnd(prevRow.cells[prevRow.cells.length - 1], selection);
                            }
                        }
                    } else {
                        let nextCell = tableCell.nextElementSibling;
                        if (nextCell) {
                            moveCursorToEnd(nextCell, selection);
                        } else {
                            const table = tableCell.closest('table');
                            const alignments = JSON.parse(table.dataset.alignments || '[]');
                            
                            const lastAlignment = alignments.length > 0 ? alignments[alignments.length - 1] : '';
                            alignments.push(lastAlignment);
                            table.dataset.alignments = JSON.stringify(alignments);

                            const newColumnIndex = alignments.length - 1;
                            const newAlignment = alignments[newColumnIndex];
                            let newCellToFocus;

                            if (table.tHead) {
                                for (const row of table.tHead.rows) {
                                    const newTh = document.createElement('th');
                                    newTh.appendChild(document.createElement('br'));
                                    if (newAlignment) {
                                        newTh.style.textAlign = newAlignment;
                                    }
                                    row.appendChild(newTh);
                                    if (row === currentRow) {
                                        newCellToFocus = newTh;
                                    }
                                }
                            }

                            if (table.tBodies.length > 0) {
                                for (const row of table.tBodies[0].rows) {
                                    const newTd = document.createElement('td');
                                    newTd.appendChild(document.createElement('br'));
                                    if (newAlignment) {
                                        newTd.style.textAlign = newAlignment;
                                    }
                                    row.appendChild(newTd);
                                    if (row === currentRow) {
                                        newCellToFocus = newTd;
                                    }
                                }
                            }

                            if (newCellToFocus) {
                                moveCursorToEnd(newCellToFocus, selection);
                            }
                            localStorage.setItem('mySmartNote', editor.innerHTML);
                        }
                    }
                    return;
                }
            }

            if (e.key === 'Enter') {
                const handled = handleEnterKeyMarkdown(e, selection, parentElement);
                if (handled) {
                    localStorage.setItem('mySmartNote', editor.innerHTML);
                    return;
                }

                const pre = parentElement.closest('pre');
                if (pre) {
                    if (parentElement.textContent.trim() === '```') {
                        e.preventDefault();
                        const newPara = document.createElement('div');
                        newPara.innerHTML = '<br>';
                        pre.after(newPara);
                        pre.remove();
                        moveCursorToEnd(newPara, selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                    }
                    return;
                }

                const blockquote = parentElement.closest('blockquote');
                if (blockquote) {
                    if (parentElement !== blockquote && parentElement.textContent.trim() === '') {
                        e.preventDefault();
                        const newPara = document.createElement('div');
                        newPara.innerHTML = '<br>';
                        blockquote.after(newPara);
                        parentElement.remove();

                        if (!blockquote.hasChildNodes() || blockquote.textContent.trim() === '') {
                            blockquote.remove();
                        }
                        moveCursorToEnd(newPara, selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                }

                const currentLine = parentElement;
                const currentLineText = currentLine.textContent.trim();
                const previousLine = currentLine.previousElementSibling;
                let match;

                const imageRegex = /^!\[([^\]]*)\]\(([^)]+)\)$/;
                if ((match = currentLineText.match(imageRegex))) {
                    e.preventDefault();
                    const altText = match[1];
                    const imageUrl = match[2];
                    const figure = document.createElement('figure');
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.alt = altText;
                    figure.appendChild(img);
                    if (altText) {
                        const figcaption = document.createElement('figcaption');
                        figcaption.textContent = altText;
                        figure.appendChild(figcaption);
                    }
                    const newPara = document.createElement('div');
                    newPara.innerHTML = '<br>';
                    currentLine.replaceWith(figure);
                    figure.after(newPara);
                    moveCursorToEnd(newPara, selection);
                    localStorage.setItem('mySmartNote', editor.innerHTML);
                    return;
                }

                const separatorRegex = /^\|(?:\s*:?-+:?\s*\|)+$/;
                if (previousLine && currentLineText.match(separatorRegex)) {
                    const headers = previousLine.textContent.split('|').slice(1, -1).map(h => h.trim());
                    if (headers.length > 0) {
                        e.preventDefault();

                        const aligners = currentLineText.split('|').slice(1, -1).map(s => s.trim());
                        const alignments = aligners.map(aligner => {
                            const startsWithColon = aligner.startsWith(':');
                            const endsWithColon = aligner.endsWith(':');
                            if (startsWithColon && endsWithColon) return 'center';
                            if (startsWithColon) return 'right';
                            if (endsWithColon) return 'left';
                            return '';
                        });

                        const table = document.createElement('table');
                        table.dataset.alignments = JSON.stringify(alignments);

                        const thead = table.createTHead();
                        const headerRow = thead.insertRow();
                        headers.forEach((headerText, index) => {
                            const th = document.createElement('th');
                            th.textContent = headerText;
                            if (alignments[index]) {
                                th.style.textAlign = alignments[index];
                            }
                            headerRow.appendChild(th);
                        });

                        const tbody = table.createTBody();
                        const firstDataRow = tbody.insertRow();
                        for (let i = 0; i < headers.length; i++) {
                            const cell = firstDataRow.insertCell(i);
                            cell.appendChild(document.createElement('br'));
                            if (alignments[i]) {
                                cell.style.textAlign = alignments[i];
                            }
                        }

                        previousLine.replaceWith(table);
                        currentLine.remove();
                        moveCursorToEnd(firstDataRow.cells[0], selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                }

                if (currentLineText.startsWith('```')) {
                    e.preventDefault();
                    const lang = currentLineText.substring(3);
                    const newPre = document.createElement('pre');
                    const newCode = document.createElement('code');
                    if (lang) newCode.className = `language-${lang}`;
                    newCode.innerHTML = '<br>';
                    newPre.appendChild(newCode);
                    currentLine.replaceWith(newPre);
                    moveCursorToEnd(newCode, selection);
                    localStorage.setItem('mySmartNote', editor.innerHTML);
                    return;
                }

                const listItemOnEnter = parentElement.closest('li');
                if (listItemOnEnter) {
                    if (listItemOnEnter.textContent.trim() === '') {
                        e.preventDefault();
                        const parentList = listItemOnEnter.parentElement;
                        const parentLi = parentList.parentElement.closest('li');
                        if (parentLi) {
                            parentLi.after(listItemOnEnter);
                            if (parentList.children.length === 0) {
                                parentList.remove();
                            }
                            moveCursorToEnd(listItemOnEnter, selection);
                        } else {
                            const list = listItemOnEnter.parentElement;
                            const newPara = document.createElement('div');
                            newPara.innerHTML = '<br>';
                            list.after(newPara);
                            listItemOnEnter.remove();
                            if (list.children.length === 0) {
                                list.remove();
                            }
                            moveCursorToEnd(newPara, selection);
                        }
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                    if (listItemOnEnter.classList.contains('checklist-item')) {
                        e.preventDefault();
                        const newLi = createChecklistItem('', false);
                        listItemOnEnter.after(newLi);
                        moveCursorToEnd(newLi, selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                }
            }
        });

        editor.addEventListener('keyup', (e) => {
            if (activeRawNode) return;

            if (e.key === ' ') {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                const range = selection.getRangeAt(0);
                const node = range.startContainer;

                if (node.parentElement.closest('pre')) {
                    return;
                }

                const parentLi = node.parentElement.closest('li');
                if (parentLi) {
                    const liText = parentLi.textContent;
                    let match;
                    if ((match = liText.match(/^\[([ xX]?)\]\s$/))) {
                        const isChecked = match[1].toLowerCase() === 'x';
                        const list = parentLi.parentElement;
                        list.classList.add('checklist');
                        const newChecklistItem = createChecklistItem('', isChecked);
                        parentLi.replaceWith(newChecklistItem);
                        moveCursorToEnd(newChecklistItem, selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                }
                if (node.nodeType === Node.TEXT_NODE) {
                    const text = node.textContent.substring(0, range.startOffset);
                    let match;
                    const parentBlock = node.parentElement;

                    if (parentBlock && parentBlock.parentElement === editor) {
                        if ((match = text.match(/^(#{1,4}) ([^\n]+?)\s$/))) {
                            const level = match[1].length;
                            const content = match[2];
                            const newHeading = document.createElement(`h${level}`);
                            newHeading.textContent = content;
                            editor.replaceChild(newHeading, parentBlock);
                            moveCursorToEnd(newHeading, selection);
                            return;
                        } else if ((match = text.match(/^> ([^\n]*?)\s$/))) {
                            const content = match[1];
                            const newQuote = document.createElement('blockquote');
                            const line = document.createElement('div');
                            if (content === '') {
                                line.appendChild(document.createElement('br'));
                            } else {
                                line.textContent = content;
                            }
                            newQuote.appendChild(line);
                            editor.replaceChild(newQuote, parentBlock);
                            moveCursorToEnd(line, selection);
                            return;
                        } else if ((match = text.match(/^(\d+)\.\s([^\n]*?)\s$/))) {
                            const content = match[2];
                            const ol = document.createElement('ol');
                            const li = document.createElement('li');
                            const startNum = parseInt(match[1], 10);
                            if (startNum > 1) {
                                ol.setAttribute('start', startNum);
                            }
                            if (content === '') {
                                li.appendChild(document.createElement('br'));
                            } else {
                                li.textContent = content;
                            }
                            ol.appendChild(li);
                            editor.replaceChild(ol, parentBlock);
                            moveCursorToEnd(li, selection);
                            return;
                        } else if ((match = text.match(/^([*-])\s([^\n]*?)\s$/))) {
                            const content = match[2];
                            const ul = document.createElement('ul');
                            const li = document.createElement('li');
                            if (content === '') {
                                li.appendChild(document.createElement('br'));
                            } else {
                                li.textContent = content;
                            }
                            ul.appendChild(li);
                            editor.replaceChild(ul, parentBlock);
                            moveCursorToEnd(li, selection);
                            return;
                        }
                    }
                    if ((match = text.match(/`([^`]+)`\s$/))) {
                        replaceMarkdown(node, match, (m) => {
                            const code = document.createElement('code');
                            code.textContent = m[1];
                            return code;
                        });
                    }
                    if ((match = text.match(/(?<!\!)\[([^\]]+)\]\(([^)]+)\)\s$/))) {
                        replaceMarkdown(node, match, (m) => {
                            const a = document.createElement('a');
                            a.href = m[2];
                            a.textContent = m[1];
                            a.target = '_blank';
                            return a;
                        });
                    } else if ((match = text.match(/\*\*([^*]+)\*\*\s$/))) {
                        replaceMarkdown(node, match, (m) => {
                            const strong = document.createElement('strong');
                            strong.textContent = m[1];
                            return strong;
                        });
                    } else if ((match = text.match(/\*([^*]+)\*\s$/))) {
                        replaceMarkdown(node, match, (m) => {
                            const em = document.createElement('em');
                            em.textContent = m[1];
                            return em;
                        });
                    } else if ((match = text.match(/~~([^~]+)~~\s$/))) {
                        replaceMarkdown(node, match, (m) => {
                            const del = document.createElement('del');
                            del.textContent = m[1];
                            return del;
                        });
                    }
                }
            }
        });

        function handleEnterKeyMarkdown(e, selection, parentElement) {
            if (parentElement.parentElement !== editor) {
                return false;
            }
            
            const text = parentElement.textContent;
            let match;

            if ((match = text.match(/^(#{1,4}) ([^\n]+?)$/))) {
                e.preventDefault();
                const level = match[1].length;
                const content = match[2];
                const newHeading = document.createElement(`h${level}`);
                newHeading.textContent = content;
                parentElement.replaceWith(newHeading);
                
                const newPara = document.createElement('div');
                newPara.innerHTML = '<br>';
                newHeading.after(newPara);
                moveCursorToEnd(newPara, selection);
                return true;
            }
            
            if ((match = text.match(/^> ([^\n]*?)$/))) {
                e.preventDefault();
                const content = match[1];
                const newQuote = document.createElement('blockquote');
                const line = document.createElement('div');
                if (content === '') {
                    line.appendChild(document.createElement('br'));
                } else {
                    line.textContent = content;
                }
                newQuote.appendChild(line);
                parentElement.replaceWith(newQuote);
                
                const newPara = document.createElement('div');
                newPara.innerHTML = '<br>';
                newQuote.after(newPara);
                moveCursorToEnd(newPara, selection);
                return true;
            }

            if ((match = text.match(/^(\d+)\.\s([^\n]*?)$/))) {
                e.preventDefault();
                const content = match[2];
                const ol = document.createElement('ol');
                const li = document.createElement('li');
                const startNum = parseInt(match[1], 10);
                if (startNum > 1) {
                    ol.setAttribute('start', startNum);
                }
                li.textContent = content || '';
                ol.appendChild(li);
                parentElement.replaceWith(ol);
                moveCursorToEnd(li, selection);
                return true;
            }

            if ((match = text.match(/^([*-])\s([^\n]*?)$/))) {
                e.preventDefault();
                const content = match[2];
                const ul = document.createElement('ul');
                const li = document.createElement('li');
                li.textContent = content || '';
                ul.appendChild(li);
                parentElement.replaceWith(ul);
                moveCursorToEnd(li, selection);
                return true;
            }

            const textNode = parentElement.lastChild;
            if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                const nodeText = textNode.textContent;

                const replaceAndBreak = (regex, createFn) => {
                    const match = nodeText.match(regex);
                    if (match) {
                        e.preventDefault();
                        const range = document.createRange();
                        range.setStart(textNode, match.index);
                        range.setEnd(textNode, match.index + match[0].length);
                        range.deleteContents();
                        const newElement = createFn(match);
                        range.insertNode(newElement);

                        const newPara = document.createElement('div');
                        newPara.innerHTML = '<br>';
                        parentElement.after(newPara);
                        moveCursorToEnd(newPara, selection);
                        return true;
                    }
                    return false;
                };

                if (replaceAndBreak(/`([^`]+)`$/, (m) => { const code = document.createElement('code'); code.textContent = m[1]; return code; })) {
                    return true;
                } else if (replaceAndBreak(/(?<!\!)\[([^\]]+)\]\(([^)]+)\)$/, (m) => { const a = document.createElement('a'); a.href = m[2]; a.textContent = m[1]; a.target = '_blank'; return a; })) {
                    return true;
                } else if (replaceAndBreak(/\*\*([^*]+)\*\*$/, (m) => { const strong = document.createElement('strong'); strong.textContent = m[1]; return strong; })) {
                    return true;
                } else if (replaceAndBreak(/\*([^*]+)\*$/, (m) => { const em = document.createElement('em'); em.textContent = m[1]; return em; })) {
                    return true;
                } else if (replaceAndBreak(/~~([^~]+)~~$/, (m) => { const del = document.createElement('del'); del.textContent = m[1]; return del; })) {
                    return true;
                }
            }

            return false;
        }

        function createChecklistItem(content, isChecked) {
            const li = document.createElement('li');
            li.className = 'checklist-item';
            if (isChecked) {
                li.classList.add('checked');
            }
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = isChecked;
            li.appendChild(checkbox);
            const textNode = document.createTextNode(content || '');
            li.appendChild(textNode);
            if (content === '') {
                li.appendChild(document.createElement('br'));
            }
            return li;
        }

        function moveCursorToEnd(element, selection) {
            const range = document.createRange();
            if (element.firstChild && element.firstChild.nodeName === 'BR' && element.childNodes.length === 1) {
                range.setStart(element, 0);
            } else {
                range.selectNodeContents(element);
                range.collapse(false);
            }
            selection.removeAllRanges();
            selection.addRange(range);
            element.focus();
        }

        function replaceMarkdown(textNode, match, createFn) {
            if (textNode.parentElement.closest('a, strong, em, del, h1, h2, h3, h4, code, pre')) return;
            const range = document.createRange();
            range.setStart(textNode, match.index);
            range.setEnd(textNode, match.index + match[0].length - 1);
            range.deleteContents();
            const newElement = createFn(match);
            range.insertNode(newElement);
            range.setStartAfter(newElement);
            range.collapse(true);
            const spaceNode = document.createTextNode('\u00A0');
            range.insertNode(spaceNode);
            range.setStartAfter(spaceNode);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            localStorage.setItem('mySmartNote', editor.innerHTML);
        }

        editor.addEventListener('paste', (e) => {
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData('text/plain');
            document.execCommand('insertText', false, text);
        });

        editor.addEventListener('focusout', () => {
            if (activeRawNode) {
                renderActiveNode();
            }
        });
    </script>
</body>
</html>