<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="dabir.svg" type="image/svg+xml">
    <title>دبیر</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap');

        body {
            font-family: 'Vazirmatn', sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 2rem;
            color: #333;
        }

        #editor {
            background-color: white;
            max-width: 800px;
            min-height: 90vh;
            margin: 0 auto;
            padding: 50px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
            outline: none;
            font-size: 18px;
            line-height: 1.8;
            white-space: pre-wrap;
        }

        #editor h1,
        #editor h2,
        #editor h3,
        #editor h4 {
            margin: 1.5em 0 0.5em;
            line-height: 1.3;
            font-weight: 700;
        }

        #editor h1 {
            font-size: 2em;
        }

        #editor h2 {
            font-size: 1.75em;
        }

        #editor h3 {
            font-size: 1.5em;
        }

        #editor h4 {
            font-size: 1.25em;
        }

        #editor blockquote {
            border-right: 4px solid #e0e0e0;
            padding-right: 1.5em;
            margin: 1em 0;
            color: #555;
            background-color: #f9f9f9;
        }
        
        #editor blockquote[dir="ltr"] {
            border-right: none;
            border-left: 4px solid #e0e0e0;
            padding-right: 0;
            padding-left: 1.5em;
        }

        #editor strong {
            font-weight: 700;
        }

        #editor em {
            font-style: italic;
        }

        #editor del {
            text-decoration: line-through;
            color: #888;
        }

        #editor a {
            color: #007bff;
            text-decoration: none;
            cursor: pointer;
        }

        #editor a:hover {
            text-decoration: underline;
        }

        #editor ul {
            padding-right: 2em;
        }

        #editor ol,
        #editor ul {
            margin: 1em 0;
        }

        #editor li {
            padding-right: 0.5em;
            margin-bottom: 0.5em;
        }

        /* استایل‌های جدید برای لیست‌های تودرتو */
        #editor ul ul {
            list-style-type: circle;
        }

        #editor ul ul ul {
            list-style-type: square;
        }

        #editor ul ul ul ul {
            list-style-type: disc;
        }
        
        /* بازنویسی کامل استایل لیست‌های مرتب برای فاصله‌گذاری یکسان */
        #editor ol {
            list-style-type: none;
            counter-reset: item;
            padding-right: 0;
        }

        #editor ol > li {
            display: table;
            counter-increment: item;
            padding-right: 0; /* Let the ::before handle all spacing */
        }

        #editor ol > li::before {
            content: "\200e" counters(item, ".") ".";
            display: table-cell;
            white-space: nowrap;
            width: 1%;
            padding-left: 0.8em; 
            vertical-align: top;
        }


        #editor ul ul,
        #editor ol ol,
        #editor ol ul,
        #editor ul ol {
            margin-right: -20px;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        #editor ul.checklist {
            list-style-type: none;
            padding-right: 0;
        }
        
        #editor li.checklist-item {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
        }

        /* Force nested checklist to wrap to new line and indent */
        #editor li.checklist-item > ul.checklist {
            flex-basis: 100%;
            width: 100%;
            padding-right: 2.5em;
        }

        #editor li.checklist-item input[type="checkbox"] {
            margin-left: 0.75em;
            cursor: pointer;
        }

        #editor li.checklist-item.checked {
            text-decoration: line-through;
            color: #888;
        }

        #editor code {
            font-family: 'Source Code Pro', monospace;
            background-color: #f0f0f0;
            padding: 0.1em 0.4em;
            border-radius: 4px;
            font-size: 0.9em;
        }

        #editor pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 1em;
            border-radius: 8px;
            overflow-x: auto;
            white-space: pre-wrap;
            text-align: left;
            direction: ltr;
        }

        #editor pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            font-size: 1em;
            white-space: inherit;
        }

        #editor table {
            border-collapse: collapse;
            width: 100%;
            margin: 1.5em 0;
            table-layout: fixed; /* عرض ستون‌ها ثابت می‌ماند */
        }

        #editor th,
        #editor td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: right;
            overflow-wrap: break-word; /* متن طولانی شکسته می‌شود */
        }

        #editor th {
            background-color: #f7f7f7;
            font-weight: 700;
        }

        #editor tr:nth-child(even) {
            background-color: #fcfcfc;
        }

        #editor:empty:before {
            content: attr(data-placeholder);
            color: #999;
            pointer-events: none;
        }

        /* ۱. استایل‌های جدید برای عکس و زیرنویس */
        #editor figure {
            margin: 1.5em 0;
            text-align: center;
        }

        #editor figure img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        #editor figure figcaption {
            margin-top: 0.8em;
            font-size: 0.9em;
            color: #666;
            font-style: italic;
        }
        
        /* استایل‌های جدید برای جهت‌دهی خودکار متن */
        #editor [dir="ltr"] {
            text-align: left;
        }
        
        #editor [dir="rtl"] {
            text-align: right;
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "react/": "https://aistudiocdn.com/react@^19.1.1/",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/"
  }
}
</script>
</head>
<body>
    <div id="editor" contenteditable="true" data-placeholder="اینجا بنویسید..."></div>

    <script>
        const editor = document.getElementById('editor');
        let activeRawNode = null;
        let ignoreSelectionChange = false;

        function detectAndSetDirection(element) {
            const text = element.textContent;
            
            // Find the first character that is a letter (either LTR or RTL).
            const firstLetterMatch = text.match(/[a-zA-Z\u0600-\u06FF]/);

            if (firstLetterMatch) {
                // Check if the first found letter is an RTL character (e.g., Arabic, Persian).
                if (/[\u0600-\u06FF]/.test(firstLetterMatch[0])) {
                    element.dir = 'rtl';
                } else {
                    element.dir = 'ltr';
                }
            } else {
                // If no letters are found (e.g., empty line, or only numbers/symbols),
                // default to RTL as per requirements.
                element.dir = 'rtl';
            }
        }

        function updateAllDirections() {
            // This selector covers paragraphs (div), headings, list items, blockquotes, and table cells.
            const lineElements = editor.querySelectorAll('div, h1, h2, h3, h4, li, th, td, blockquote, figcaption');
            lineElements.forEach(detectAndSetDirection);
        }

        window.addEventListener('load', () => {
            const savedContent = localStorage.getItem('mySmartNote');
            if (savedContent) {
                editor.innerHTML = savedContent;
            }
            updateAllDirections();
        });
        editor.addEventListener('input', () => {
            if (!activeRawNode) {
                localStorage.setItem('mySmartNote', editor.innerHTML);
            }
            updateAllDirections();
        });

        function elementToRawMarkdown(el) {
            const text = el.textContent;
            switch (el.tagName) {
                case 'STRONG': return `**${text}**`;
                case 'EM':     return `*${text}*`;
                case 'DEL':    return `~~${text}~~`;
                case 'CODE':   return `\`${text}\``;
                case 'A':      return `[${text}](${el.getAttribute('href')})`;
                case 'H1':     return `# ${text}`;
                case 'H2':     return `## ${text}`;
                case 'H3':     return `### ${text}`;
                case 'H4':     return `#### ${text}`;
                case 'FIGURE': {
                    const img = el.querySelector('img');
                    const figcaption = el.querySelector('figcaption');
                    const alt = figcaption ? figcaption.textContent : (img ? img.alt : '');
                    const src = img ? img.src : '';
                    return `![${alt}](${src})`;
                }
                case 'BLOCKQUOTE': {
                    return Array.from(el.children)
                                .map(child => `> ${child.textContent}`)
                                .join('\n');
                }
                default:       return text;
            }
        }

        function renderRawMarkdownNode(textNode) {
            if (!textNode || textNode.nodeType !== Node.TEXT_NODE || !textNode.parentElement) return null;
    
            const text = textNode.textContent;
            const parent = textNode.parentElement;
            let match;
            let newNode = null;
            let isBlock = false;

            // Block-level elements are handled when the parent is a DIV directly under the editor
            if (parent.tagName === 'DIV' && parent.parentElement === editor) {
                if ((match = text.match(/^(#{1,4}) ([^\n]+?)$/))) {
                    const level = match[1].length;
                    newNode = document.createElement(`h${level}`);
                    newNode.textContent = match[2];
                    isBlock = true;
                } else if ((match = text.match(/^!\[([^\]]*)\]\(([^)]+)\)$/))) {
                    const altText = match[1];
                    const imageUrl = match[2];
                    newNode = document.createElement('figure');
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.alt = altText;
                    newNode.appendChild(img);
                    if (altText) {
                        const figcaption = document.createElement('figcaption');
                        figcaption.textContent = altText;
                        newNode.appendChild(figcaption);
                    }
                    isBlock = true;
                } else if (text.startsWith('> ')) {
                    const lines = text.split('\n').filter(line => line.startsWith('> '));
                    if (lines.length > 0 && lines.every(line => line.startsWith('> '))) {
                        newNode = document.createElement('blockquote');
                        lines.forEach(line => {
                            const lineDiv = document.createElement('div');
                            const content = line.substring(2);
                            if (content) {
                                lineDiv.textContent = content;
                            } else {
                                lineDiv.appendChild(document.createElement('br'));
                            }
                            newNode.appendChild(lineDiv);
                        });
                        isBlock = true;
                    }
                }
            }
            
            if (!isBlock) { // Check for inline elements if no block element was matched
                if ((match = text.match(/^\*\*([^*]+)\*\*$/))) {
                    newNode = document.createElement('strong');
                    newNode.textContent = match[1];
                } else if ((match = text.match(/^\*([^*]+)\*$/))) {
                    newNode = document.createElement('em');
                    newNode.textContent = match[1];
                } else if ((match = text.match(/^~~([^~]+)~~$/))) {
                    newNode = document.createElement('del');
                    newNode.textContent = match[1];
                } else if ((match = text.match(/^`([^`]+)`$/))) {
                    newNode = document.createElement('code');
                    newNode.textContent = match[1];
                } else if ((match = text.match(/^\[([^\]]+)\]\(([^)]+)\)$/))) {
                    newNode = document.createElement('a');
                    newNode.textContent = match[1];
                    newNode.href = match[2];
                    newNode.target = '_blank';
                }
            }

            if (newNode) {
                const selection = window.getSelection();
                const range = document.createRange();

                if (isBlock) {
                    parent.replaceWith(newNode);
                    moveCursorToEnd(newNode, selection);
                } else {
                    textNode.replaceWith(newNode);
                    range.setStartAfter(newNode);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
                
                localStorage.setItem('mySmartNote', editor.innerHTML);
                return newNode;
            }
            return null;
        }

        function revealMarkdown(element) {
            if (activeRawNode) {
                renderRawMarkdownNode(activeRawNode);
            }

            const rawText = elementToRawMarkdown(element);
            const textNode = document.createTextNode(rawText);
            
            const isBlock = ['H1', 'H2', 'H3', 'H4', 'FIGURE', 'BLOCKQUOTE'].includes(element.tagName);
            if (isBlock) {
                const newDiv = document.createElement('div');
                newDiv.appendChild(textNode);
                element.replaceWith(newDiv);
            } else {
                element.replaceWith(textNode);
            }
            activeRawNode = textNode;

            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(textNode);
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
        }

        function renderActiveNode() {
            if (!activeRawNode) return;
            
            ignoreSelectionChange = true;
            
            const nodeToRender = activeRawNode;
            activeRawNode = null; 
            renderRawMarkdownNode(nodeToRender);

            setTimeout(() => { ignoreSelectionChange = false; }, 0);
        }

        document.addEventListener('selectionchange', () => {
            if (ignoreSelectionChange) return;

            const selection = window.getSelection();
            if (!selection || !selection.rangeCount) return;
            const anchorNode = selection.anchorNode;

            if (!editor.contains(anchorNode)) {
                if (activeRawNode) renderActiveNode();
                return;
            }

            const parentElement = anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;

            if (activeRawNode && anchorNode !== activeRawNode) {
                renderActiveNode();
                return; 
            }

            if (selection.isCollapsed && !activeRawNode) {
                const elementToReveal = parentElement.closest('strong, em, del, code, a, h1, h2, h3, h4, figure, blockquote');
                if (elementToReveal && !elementToReveal.closest('pre, table, li')) {
                    ignoreSelectionChange = true;
                    revealMarkdown(elementToReveal);
                    setTimeout(() => { ignoreSelectionChange = false; }, 0);
                }
            }
        });

        editor.addEventListener('click', (e) => {
            const target = e.target;
            
            const link = target.closest('a');
            if (link && (e.metaKey || e.ctrlKey)) {
                e.preventDefault();
                window.open(link.href, '_blank');
                return;
            }
            
            if (target.tagName === 'INPUT' && target.type === 'checkbox') {
                const checklistItem = target.closest('li.checklist-item');
                if (checklistItem) {
                    setTimeout(() => {
                        checklistItem.classList.toggle('checked', target.checked);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                    }, 0);
                }
            }
        });

        editor.addEventListener('keydown', (e) => {
            if (activeRawNode && e.key === 'Escape') {
                e.preventDefault();
                renderActiveNode();
                return;
            }
            
            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            const range = selection.getRangeAt(0);
            const parentElement = selection.anchorNode.nodeType === 3 ?
                selection.anchorNode.parentElement :
                selection.anchorNode;

            const listItem = parentElement.closest('li');
            if (listItem && e.key === 'Tab') {
                e.preventDefault();
                if (e.shiftKey) {
                    const parentList = listItem.parentElement;
                    const parentLi = parentList.parentElement.closest('li');
                    if (parentLi) {
                        parentLi.after(listItem);
                        if (parentList.children.length === 0) {
                            parentList.remove();
                        }
                        moveCursorToEnd(listItem, selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                    }
                } else {
                    const previousLi = listItem.previousElementSibling;
                    if (previousLi) {
                        let depth = 0;
                        let el = listItem;
                        while ((el = el.closest('ul, ol')?.parentElement?.closest('li'))) {
                            depth++;
                        }
                        
                        const parentListTag = listItem.parentElement.tagName;
                        const maxDepth = parentListTag === 'OL' ? 3 : 4;

                        if (depth < maxDepth) {
                            let sublist = previousLi.querySelector('ul, ol');
                            if (!sublist) {
                                sublist = document.createElement(parentListTag);
                                if (listItem.classList.contains('checklist-item')) {
                                    sublist.classList.add('checklist');
                                }
                                previousLi.appendChild(sublist);
                            }
                            sublist.appendChild(listItem);
                            moveCursorToEnd(listItem, selection);
                            localStorage.setItem('mySmartNote', editor.innerHTML);
                        }
                    }
                }
                return;
            }
            
            const checklistItem = parentElement.closest('li.checklist-item');
            if (e.key === 'Backspace' && selection.isCollapsed && checklistItem && checklistItem.textContent.trim() === '') {
                if ((range.startContainer === checklistItem && range.startOffset <= 1) || (range.startContainer.parentElement === checklistItem && range.startOffset === 0)) {
                    e.preventDefault();
                    
                    const parentList = checklistItem.parentElement;
                    const previousItem = checklistItem.previousElementSibling;

                    if (previousItem) {
                        checklistItem.remove();
                        moveCursorToEnd(previousItem, selection);
                    } else {
                        const newPara = document.createElement('div');
                        newPara.innerHTML = '<br>';
                        
                        const parentLi = parentList.parentElement.closest('li');
                        if(parentLi) {
                            parentList.remove();
                            moveCursorToEnd(parentLi, selection);
                        } else {
                            parentList.before(newPara);
                             if (parentList.children.length === 1) {
                                parentList.remove();
                            }
                            checklistItem.remove();
                            moveCursorToEnd(newPara, selection);
                        }
                    }
                    
                    localStorage.setItem('mySmartNote', editor.innerHTML);
                    return;
                }
            }


            const tableCell = parentElement.closest('th, td');
            if (tableCell) {
                const currentRow = tableCell.parentElement;

                if (e.key === 'Backspace' &&
                    selection.isCollapsed &&
                    range.startOffset === 0 &&
                    tableCell === currentRow.cells[0]) {

                    const isRowEmpty = Array.from(currentRow.cells).every(cell => cell.textContent.trim() === '');

                    if (isRowEmpty) {
                        e.preventDefault();
                        
                        const table = tableCell.closest('table');
                        const isHeaderRow = currentRow.parentElement.tagName === 'THEAD';

                        const previousRow = currentRow.previousElementSibling;
                        const nextRow = currentRow.nextElementSibling;
                        const firstBodyRow = table.tBodies[0]?.rows[0];
                        const lastHeaderRow = table.tHead?.rows[table.tHead.rows.length - 1];

                        const parentContainer = currentRow.parentElement;
                        currentRow.remove();
                        if (parentContainer.rows.length === 0) {
                            parentContainer.remove();
                        }

                        if (table.rows.length === 0) {
                            const newPara = document.createElement('div');
                            newPara.innerHTML = '<br>';
                            table.after(newPara);
                            table.remove();
                            moveCursorToEnd(newPara, selection);
                        } else if (isHeaderRow) {
                            if (firstBodyRow) {
                                moveCursorToEnd(firstBodyRow.cells[0], selection);
                            }
                        } else { 
                            if (previousRow) {
                                moveCursorToEnd(previousRow.cells[previousRow.cells.length - 1], selection);
                            } else if (nextRow) {
                                moveCursorToEnd(nextRow.cells[0], selection);
                            } else if (lastHeaderRow) {
                                moveCursorToEnd(lastHeaderRow.cells[lastHeaderRow.cells.length - 1], selection);
                            }
                        }
                        
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                }

                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (currentRow.parentElement.tagName === 'TBODY' &&
                        !currentRow.nextElementSibling &&
                        Array.from(currentRow.cells).every(cell => cell.textContent.trim() === '')) {
                        const table = tableCell.closest('table');
                        const newPara = document.createElement('div');
                        newPara.innerHTML = '<br>';
                        table.after(newPara);
                        currentRow.remove();
                        moveCursorToEnd(newPara, selection);
                    } else {
                        const table = tableCell.closest('table');
                        const alignments = JSON.parse(table.dataset.alignments || '[]');
                        const newRow = currentRow.parentElement.insertRow(currentRow.rowIndex);
                        for (let i = 0; i < currentRow.cells.length; i++) {
                            const cell = newRow.insertCell(i);
                            cell.appendChild(document.createElement('br'));
                            if (alignments[i]) {
                                cell.style.textAlign = alignments[i];
                            }
                        }
                        moveCursorToEnd(newRow.cells[0], selection);
                    }
                    localStorage.setItem('mySmartNote', editor.innerHTML);
                    return;
                }

                if (e.key === 'Tab') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        let prevCell = tableCell.previousElementSibling;
                        if (prevCell) {
                            moveCursorToEnd(prevCell, selection);
                        } else {
                            const prevRow = currentRow.previousElementSibling;
                            if (prevRow) {
                                moveCursorToEnd(prevRow.cells[prevRow.cells.length - 1], selection);
                            }
                        }
                    } else {
                        let nextCell = tableCell.nextElementSibling;
                        if (nextCell) {
                            moveCursorToEnd(nextCell, selection);
                        } else {
                            const table = tableCell.closest('table');
                            const alignments = JSON.parse(table.dataset.alignments || '[]');
                            
                            const lastAlignment = alignments.length > 0 ? alignments[alignments.length - 1] : '';
                            alignments.push(lastAlignment);
                            table.dataset.alignments = JSON.stringify(alignments);

                            const newColumnIndex = alignments.length - 1;
                            const newAlignment = alignments[newColumnIndex];
                            let newCellToFocus;

                            if (table.tHead) {
                                for (const row of table.tHead.rows) {
                                    const newTh = document.createElement('th');
                                    newTh.appendChild(document.createElement('br'));
                                    if (newAlignment) {
                                        newTh.style.textAlign = newAlignment;
                                    }
                                    row.appendChild(newTh);
                                    if (row === currentRow) {
                                        newCellToFocus = newTh;
                                    }
                                }
                            }

                            if (table.tBodies.length > 0) {
                                for (const row of table.tBodies[0].rows) {
                                    const newTd = document.createElement('td');
                                    newTd.appendChild(document.createElement('br'));
                                    if (newAlignment) {
                                        newTd.style.textAlign = newAlignment;
                                    }
                                    row.appendChild(newTd);
                                    if (row === currentRow) {
                                        newCellToFocus = newTd;
                                    }
                                }
                            }

                            if (newCellToFocus) {
                                moveCursorToEnd(newCellToFocus, selection);
                            }
                            localStorage.setItem('mySmartNote', editor.innerHTML);
                        }
                    }
                    return;
                }
            }

            if (e.key === 'Enter') {
                const handled = handleEnterKeyMarkdown(e, selection, parentElement);
                if (handled) {
                    localStorage.setItem('mySmartNote', editor.innerHTML);
                    return;
                }

                const pre = parentElement.closest('pre');
                if (pre) {
                    if (parentElement.textContent.trim() === '```') {
                        e.preventDefault();
                        const newPara = document.createElement('div');
                        newPara.innerHTML = '<br>';
                        pre.after(newPara);
                        pre.remove();
                        moveCursorToEnd(newPara, selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                    }
                    return;
                }

                const blockquote = parentElement.closest('blockquote');
                if (blockquote) {
                    if (parentElement !== blockquote && parentElement.textContent.trim() === '') {
                        e.preventDefault();
                        const newPara = document.createElement('div');
                        newPara.innerHTML = '<br>';
                        blockquote.after(newPara);
                        parentElement.remove();

                        if (!blockquote.hasChildNodes() || blockquote.textContent.trim() === '') {
                            blockquote.remove();
                        }
                        moveCursorToEnd(newPara, selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                }

                const currentLine = parentElement;
                const currentLineText = currentLine.textContent.trim();
                const previousLine = currentLine.previousElementSibling;
                let match;

                const imageRegex = /^!\[([^\]]*)\]\(([^)]+)\)$/;
                if ((match = currentLineText.match(imageRegex))) {
                    e.preventDefault();
                    const altText = match[1];
                    const imageUrl = match[2];
                    const figure = document.createElement('figure');
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.alt = altText;
                    figure.appendChild(img);
                    if (altText) {
                        const figcaption = document.createElement('figcaption');
                        figcaption.textContent = altText;
                        figure.appendChild(figcaption);
                    }
                    const newPara = document.createElement('div');
                    newPara.innerHTML = '<br>';
                    currentLine.replaceWith(figure);
                    figure.after(newPara);
                    moveCursorToEnd(newPara, selection);
                    localStorage.setItem('mySmartNote', editor.innerHTML);
                    return;
                }

                const separatorRegex = /^\|(?:\s*:?-+:?\s*\|)+$/;
                if (previousLine && currentLineText.match(separatorRegex)) {
                    const headers = previousLine.textContent.split('|').slice(1, -1).map(h => h.trim());
                    if (headers.length > 0) {
                        e.preventDefault();

                        const aligners = currentLineText.split('|').slice(1, -1).map(s => s.trim());
                        const alignments = aligners.map(aligner => {
                            const startsWithColon = aligner.startsWith(':');
                            const endsWithColon = aligner.endsWith(':');
                            if (startsWithColon && endsWithColon) return 'center';
                            if (startsWithColon) return 'right';
                            if (endsWithColon) return 'left';
                            return '';
                        });

                        const table = document.createElement('table');
                        table.dataset.alignments = JSON.stringify(alignments);

                        const thead = table.createTHead();
                        const headerRow = thead.insertRow();
                        headers.forEach((headerText, index) => {
                            const th = document.createElement('th');
                            th.textContent = headerText;
                            if (alignments[index]) {
                                th.style.textAlign = alignments[index];
                            }
                            headerRow.appendChild(th);
                        });

                        const tbody = table.createTBody();
                        const firstDataRow = tbody.insertRow();
                        for (let i = 0; i < headers.length; i++) {
                            const cell = firstDataRow.insertCell(i);
                            cell.appendChild(document.createElement('br'));
                            if (alignments[i]) {
                                cell.style.textAlign = alignments[i];
                            }
                        }

                        previousLine.replaceWith(table);
                        currentLine.remove();
                        moveCursorToEnd(firstDataRow.cells[0], selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                }

                if (currentLineText.startsWith('```')) {
                    e.preventDefault();
                    const lang = currentLineText.substring(3);
                    const newPre = document.createElement('pre');
                    const newCode = document.createElement('code');
                    if (lang) newCode.className = `language-${lang}`;
                    newCode.innerHTML = '<br>';
                    newPre.appendChild(newCode);
                    currentLine.replaceWith(newPre);
                    moveCursorToEnd(newCode, selection);
                    localStorage.setItem('mySmartNote', editor.innerHTML);
                    return;
                }

                const listItemOnEnter = parentElement.closest('li');
                if (listItemOnEnter) {
                    if (listItemOnEnter.textContent.trim() === '') {
                        e.preventDefault();
                        const parentList = listItemOnEnter.parentElement;
                        const parentLi = parentList.parentElement.closest('li');
                        if (parentLi) {
                            parentLi.after(listItemOnEnter);
                            if (parentList.children.length === 0) {
                                parentList.remove();
                            }
                            moveCursorToEnd(listItemOnEnter, selection);
                        } else {
                            const list = listItemOnEnter.parentElement;
                            const newPara = document.createElement('div');
                            newPara.innerHTML = '<br>';
                            list.after(newPara);
                            listItemOnEnter.remove();
                            if (list.children.length === 0) {
                                list.remove();
                            }
                            moveCursorToEnd(newPara, selection);
                        }
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                    if (listItemOnEnter.classList.contains('checklist-item')) {
                        e.preventDefault();
                        const newLi = createChecklistItem('', false);
                        listItemOnEnter.after(newLi);
                        moveCursorToEnd(newLi, selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                }
            }
        });

        editor.addEventListener('keyup', (e) => {
            if (activeRawNode) return;

            if (e.key === ' ') {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                const range = selection.getRangeAt(0);
                const node = range.startContainer;

                if (node.parentElement.closest('pre')) {
                    return;
                }

                const parentLi = node.parentElement.closest('li');
                if (parentLi) {
                    const liText = parentLi.textContent;
                    let match;
                    if ((match = liText.match(/^\[([ xX]?)\]\s$/))) {
                        const isChecked = match[1].toLowerCase() === 'x';
                        const list = parentLi.parentElement;
                        list.classList.add('checklist');
                        const newChecklistItem = createChecklistItem('', isChecked);
                        parentLi.replaceWith(newChecklistItem);
                        moveCursorToEnd(newChecklistItem, selection);
                        localStorage.setItem('mySmartNote', editor.innerHTML);
                        return;
                    }
                }
                if (node.nodeType === Node.TEXT_NODE) {
                    const text = node.textContent.substring(0, range.startOffset);
                    let match;
                    const parentBlock = node.parentElement;

                    if (parentBlock && parentBlock.parentElement === editor) {
                        if ((match = text.match(/^(#{1,4}) ([^\n]+?)\s$/))) {
                            const level = match[1].length;
                            const content = match[2];
                            const newHeading = document.createElement(`h${level}`);
                            newHeading.textContent = content;
                            editor.replaceChild(newHeading, parentBlock);
                            moveCursorToEnd(newHeading, selection);
                            return;
                        } else if ((match = text.match(/^> ([^\n]*?)\s$/))) {
                            const content = match[1];
                            const newQuote = document.createElement('blockquote');
                            const line = document.createElement('div');
                            if (content === '') {
                                line.appendChild(document.createElement('br'));
                            } else {
                                line.textContent = content;
                            }
                            newQuote.appendChild(line);
                            editor.replaceChild(newQuote, parentBlock);
                            moveCursorToEnd(line, selection);
                            return;
                        } else if ((match = text.match(/^(\d+)\.\s([^\n]*?)\s$/))) {
                            const content = match[2];
                            const ol = document.createElement('ol');
                            const li = document.createElement('li');
                            const startNum = parseInt(match[1], 10);
                            if (startNum > 1) {
                                ol.setAttribute('start', startNum);
                            }
                            if (content === '') {
                                li.appendChild(document.createElement('br'));
                            } else {
                                li.textContent = content;
                            }
                            ol.appendChild(li);
                            editor.replaceChild(ol, parentBlock);
                            moveCursorToEnd(li, selection);
                            return;
                        } else if ((match = text.match(/^([*-])\s([^\n]*?)\s$/))) {
                            const content = match[2];
                            const ul = document.createElement('ul');
                            const li = document.createElement('li');
                            if (content === '') {
                                li.appendChild(document.createElement('br'));
                            } else {
                                li.textContent = content;
                            }
                            ul.appendChild(li);
                            editor.replaceChild(ul, parentBlock);
                            moveCursorToEnd(li, selection);
                            return;
                        }
                    }
                    if ((match = text.match(/`([^`]+)`\s$/))) {
                        replaceMarkdown(node, match, (m) => {
                            const code = document.createElement('code');
                            code.textContent = m[1];
                            return code;
                        });
                    }
                    if ((match = text.match(/(?<!\!)\[([^\]]+)\]\(([^)]+)\)\s$/))) {
                        replaceMarkdown(node, match, (m) => {
                            const a = document.createElement('a');
                            a.href = m[2];
                            a.textContent = m[1];
                            a.target = '_blank';
                            return a;
                        });
                    } else if ((match = text.match(/\*\*([^*]+)\*\*\s$/))) {
                        replaceMarkdown(node, match, (m) => {
                            const strong = document.createElement('strong');
                            strong.textContent = m[1];
                            return strong;
                        });
                    } else if ((match = text.match(/\*([^*]+)\*\s$/))) {
                        replaceMarkdown(node, match, (m) => {
                            const em = document.createElement('em');
                            em.textContent = m[1];
                            return em;
                        });
                    } else if ((match = text.match(/~~([^~]+)~~\s$/))) {
                        replaceMarkdown(node, match, (m) => {
                            const del = document.createElement('del');
                            del.textContent = m[1];
                            return del;
                        });
                    }
                }
            }
        });

        function handleEnterKeyMarkdown(e, selection, parentElement) {
            if (parentElement.parentElement !== editor) {
                return false;
            }
            
            const text = parentElement.textContent;
            let match;

            if ((match = text.match(/^(#{1,4}) ([^\n]+?)$/))) {
                e.preventDefault();
                const level = match[1].length;
                const content = match[2];
                const newHeading = document.createElement(`h${level}`);
                newHeading.textContent = content;
                parentElement.replaceWith(newHeading);
                
                const newPara = document.createElement('div');
                newPara.innerHTML = '<br>';
                newHeading.after(newPara);
                moveCursorToEnd(newPara, selection);
                return true;
            }
            
            if ((match = text.match(/^> ([^\n]*?)$/))) {
                e.preventDefault();
                const content = match[1];
                const newQuote = document.createElement('blockquote');
                const line = document.createElement('div');
                if (content === '') {
                    line.appendChild(document.createElement('br'));
                } else {
                    line.textContent = content;
                }
                newQuote.appendChild(line);
                parentElement.replaceWith(newQuote);
                
                const newPara = document.createElement('div');
                newPara.innerHTML = '<br>';
                newQuote.after(newPara);
                moveCursorToEnd(newPara, selection);
                return true;
            }

            if ((match = text.match(/^(\d+)\.\s([^\n]*?)$/))) {
                e.preventDefault();
                const content = match[2];
                const ol = document.createElement('ol');
                const li = document.createElement('li');
                const startNum = parseInt(match[1], 10);
                if (startNum > 1) {
                    ol.setAttribute('start', startNum);
                }
                li.textContent = content || '';
                ol.appendChild(li);
                parentElement.replaceWith(ol);
                moveCursorToEnd(li, selection);
                return true;
            }

            if ((match = text.match(/^([*-])\s([^\n]*?)$/))) {
                e.preventDefault();
                const content = match[2];
                const ul = document.createElement('ul');
                const li = document.createElement('li');
                li.textContent = content || '';
                ul.appendChild(li);
                parentElement.replaceWith(ul);
                moveCursorToEnd(li, selection);
                return true;
            }

            const textNode = parentElement.lastChild;
            if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                const nodeText = textNode.textContent;

                const replaceAndBreak = (regex, createFn) => {
                    const match = nodeText.match(regex);
                    if (match) {
                        e.preventDefault();
                        const range = document.createRange();
                        range.setStart(textNode, match.index);
                        range.setEnd(textNode, match.index + match[0].length);
                        range.deleteContents();
                        const newElement = createFn(match);
                        range.insertNode(newElement);

                        const newPara = document.createElement('div');
                        newPara.innerHTML = '<br>';
                        parentElement.after(newPara);
                        moveCursorToEnd(newPara, selection);
                        return true;
                    }
                    return false;
                };

                if (replaceAndBreak(/`([^`]+)`$/, (m) => { const code = document.createElement('code'); code.textContent = m[1]; return code; })) {
                    return true;
                } else if (replaceAndBreak(/(?<!\!)\[([^\]]+)\]\(([^)]+)\)$/, (m) => { const a = document.createElement('a'); a.href = m[2]; a.textContent = m[1]; a.target = '_blank'; return a; })) {
                    return true;
                } else if (replaceAndBreak(/\*\*([^*]+)\*\*$/, (m) => { const strong = document.createElement('strong'); strong.textContent = m[1]; return strong; })) {
                    return true;
                } else if (replaceAndBreak(/\*([^*]+)\*$/, (m) => { const em = document.createElement('em'); em.textContent = m[1]; return em; })) {
                    return true;
                } else if (replaceAndBreak(/~~([^~]+)~~$/, (m) => { const del = document.createElement('del'); del.textContent = m[1]; return del; })) {
                    return true;
                }
            }

            return false;
        }

        function createChecklistItem(content, isChecked) {
            const li = document.createElement('li');
            li.className = 'checklist-item';
            if (isChecked) {
                li.classList.add('checked');
            }
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = isChecked;
            li.appendChild(checkbox);
            const textNode = document.createTextNode(content || '');
            li.appendChild(textNode);
            if (content === '') {
                li.appendChild(document.createElement('br'));
            }
            return li;
        }

        function moveCursorToEnd(element, selection) {
            const range = document.createRange();
            if (element.firstChild && element.firstChild.nodeName === 'BR' && element.childNodes.length === 1) {
                range.setStart(element, 0);
            } else {
                range.selectNodeContents(element);
                range.collapse(false);
            }
            selection.removeAllRanges();
            selection.addRange(range);
            element.focus();
        }

        function replaceMarkdown(textNode, match, createFn) {
            if (textNode.parentElement.closest('a, strong, em, del, h1, h2, h3, h4, code, pre')) return;
            const range = document.createRange();
            range.setStart(textNode, match.index);
            range.setEnd(textNode, match.index + match[0].length - 1);
            range.deleteContents();
            const newElement = createFn(match);
            range.insertNode(newElement);
            range.setStartAfter(newElement);
            range.collapse(true);
            const spaceNode = document.createTextNode('\u00A0');
            range.insertNode(spaceNode);
            range.setStartAfter(spaceNode);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            localStorage.setItem('mySmartNote', editor.innerHTML);
        }

        function processTableBlock(lines, startIndex, parseInline) {
            const headerLine = lines[startIndex];
            if (!headerLine.includes('|')) return null;

            const separatorLine = lines[startIndex + 1];
            if (!separatorLine || !separatorLine.match(/^\|(?:\s*:?-+:?\s*\|)+$/)) return null;
            
            const headers = headerLine.split('|').slice(1, -1).map(h => h.trim());
            if (headers.length === 0) return null;

            const aligners = separatorLine.split('|').slice(1, -1).map(s => s.trim());
            const alignments = aligners.map(aligner => {
                const startsWithColon = aligner.startsWith(':');
                const endsWithColon = aligner.endsWith(':');
                if (startsWithColon && endsWithColon) return 'center';
                if (endsWithColon) return 'left';
                if (startsWithColon) return 'right';
                return '';
            });

            let html = `<table data-alignments='${JSON.stringify(alignments)}'>`;
            html += '<thead><tr>';
            headers.forEach((headerText, index) => {
                const alignStyle = alignments[index] ? ` style="text-align: ${alignments[index]}"` : '';
                html += `<th${alignStyle}>${parseInline(headerText)}</th>`;
            });
            html += '</tr></thead>';

            html += '<tbody>';
            let i = startIndex + 2;
            while(i < lines.length && lines[i].includes('|')) {
                const cells = lines[i].split('|').slice(1, -1);
                html += '<tr>';
                for (let j = 0; j < headers.length; j++) {
                    const cellText = (cells[j] || '').trim();
                    const alignStyle = alignments[j] ? ` style="text-align: ${alignments[j]}"` : '';
                    html += `<td${alignStyle}>${parseInline(cellText) || '<br>'}</td>`;
                }
                html += '</tr>';
                i++;
            }
            html += '</tbody></table>';

            return { html, lastIndex: i - 1 };
        }

        function processListBlock(lines, startIndex, parseInline) {
            let html = '';
            let i = startIndex;
            const listStack = []; // { type: 'ul'/'ol', indent: number }

            const getIndent = (line) => line.match(/^\s*/)[0].length;
            
            while(i < lines.length) {
                const line = lines[i];
                const trimmedLine = line.trim();
                const match = trimmedLine.match(/^([-*]|\d+\.) (.*)/);

                if (!match) break;
                
                const indent = getIndent(line);
                
                while (listStack.length > 0 && indent < listStack[listStack.length - 1].indent) {
                    html += `</${listStack.pop().type}>`;
                }
                
                const listMarker = match[1];
                let itemContent = match[2];
                const type = (listMarker === '-' || listMarker === '*') ? 'ul' : 'ol';
                
                const isChecklist = itemContent.startsWith('[ ] ') || itemContent.startsWith('[x] ') || itemContent.startsWith('[X] ');

                if (listStack.length === 0 || indent > listStack[listStack.length - 1].indent) {
                    html += `<${type}${isChecklist && type === 'ul' ? ' class="checklist"' : ''}>`;
                    listStack.push({ type, indent });
                } else if (type !== listStack[listStack.length - 1].type) {
                    html += `</${listStack.pop().type}>`;
                    html += `<${type}${isChecklist && type === 'ul' ? ' class="checklist"' : ''}>`;
                    listStack.push({ type, indent });
                }
                
                if (isChecklist) {
                    const isChecked = itemContent[1].toLowerCase() === 'x';
                    itemContent = itemContent.substring(4);
                    html += `<li class="checklist-item ${isChecked ? 'checked' : ''}"><input type="checkbox" ${isChecked ? 'checked' : ''}>${parseInline(itemContent)}</li>`;
                } else {
                    html += `<li>${parseInline(itemContent)}</li>`;
                }
                
                i++;
            }

            while(listStack.length > 0) {
                html += `</${listStack.pop().type}>`;
            }
            
            return { html, lastIndex: i - 1 };
        }

        function markdownToHtml(markdown) {
            const lines = markdown.split('\n');
            let html = '';
            let inCodeBlock = false;
            let codeLang = '';
            let currentParagraphLines = [];

            const parseInline = (text) => {
                return text
                    .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') // Escape HTML
                    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
                    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*([^*]+)\*/g, '<em>$1</em>')
                    .replace(/~~([^~]+)~~/g, '<del>$1</del>')
                    .replace(/`([^`]+)`/g, '<code>$1</code>');
            };

            const flushParagraph = () => {
                if (currentParagraphLines.length > 0) {
                    html += currentParagraphLines.map(p_line => `<div>${parseInline(p_line)}</div>`).join('');
                    currentParagraphLines = [];
                }
            };
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];

                if (inCodeBlock) {
                    if (line.trim() === '```') {
                        html += '</code></pre>';
                        inCodeBlock = false;
                    } else {
                        html += line.replace(/</g, "&lt;").replace(/>/g, "&gt;") + '\n';
                    }
                    continue;
                }

                if (line.trim().startsWith('```')) {
                    flushParagraph();
                    inCodeBlock = true;
                    codeLang = line.trim().substring(3);
                    html += `<pre><code class="language-${codeLang}">`;
                    continue;
                }
                
                let match = line.match(/^(#{1,4}) (.*)/);
                if (match) {
                    flushParagraph();
                    const level = match[1].length;
                    const content = parseInline(match[2]);
                    html += `<h${level}>${content}</h${level}>`;
                    continue;
                }

                if (line.startsWith('> ')) {
                    flushParagraph();
                    html += '<blockquote>';
                    while (i < lines.length && lines[i].startsWith('> ')) {
                        const content = parseInline(lines[i].substring(2));
                        html += `<div>${content || '<br>'}</div>`;
                        i++;
                    }
                    html += '</blockquote>';
                    i--;
                    continue;
                }
                
                if (/^(\s*[-*]|\s*\d+\.) /.test(line)) {
                    flushParagraph();
                    const listResult = processListBlock(lines, i, parseInline);
                    html += listResult.html;
                    i = listResult.lastIndex;
                    continue;
                }
                
                if (line.includes('|') && i + 1 < lines.length && lines[i+1].includes('|')) {
                    const tableResult = processTableBlock(lines, i, parseInline);
                    if (tableResult) {
                        flushParagraph();
                        html += tableResult.html;
                        i = tableResult.lastIndex;
                        continue;
                    }
                }
                
                match = line.match(/^!\[([^\]]*)\]\(([^)]+)\)$/);
                if (match) {
                    flushParagraph();
                    const alt = match[1];
                    const src = match[2];
                    html += `<figure><img src="${src}" alt="${alt}"><figcaption>${alt}</figcaption></figure>`;
                    continue;
                }

                if (line.trim() === '') {
                    flushParagraph();
                    html += '<div><br></div>';
                } else {
                    currentParagraphLines.push(line);
                }
            }
            
            flushParagraph();
            return html;
        }

        editor.addEventListener('paste', (e) => {
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData('text/plain');
            const html = markdownToHtml(text);
            if (html) {
                document.execCommand('insertHTML', false, html);
                updateAllDirections();
                localStorage.setItem('mySmartNote', editor.innerHTML);
            }
        });

        function getMarkdownFromSelection() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return '';

            const range = selection.getRangeAt(0);
            const container = document.createElement('div');
            container.appendChild(range.cloneContents());

            function convertNode(node, listState = {}) {
                if (node.nodeType === Node.TEXT_NODE) {
                    return node.textContent;
                }

                if (node.nodeType !== Node.ELEMENT_NODE) {
                    return '';
                }

                let childMarkdown = Array.from(node.childNodes)
                                        .map(child => convertNode(child, listState))
                                        .join('');
                
                switch (node.tagName) {
                    case 'H1': return `# ${childMarkdown}\n\n`;
                    case 'H2': return `## ${childMarkdown}\n\n`;
                    case 'H3': return `### ${childMarkdown}\n\n`;
                    case 'H4': return `#### ${childMarkdown}\n\n`;
                    case 'STRONG': return `**${childMarkdown}**`;
                    case 'EM': return `*${childMarkdown}*`;
                    case 'DEL': return `~~${childMarkdown}~~`;
                    case 'CODE': return node.closest('pre') ? childMarkdown : `\`${childMarkdown}\``;
                    case 'A': return `[${childMarkdown}](${node.href})`;
                    case 'BR': return '\n';
                    case 'DIV': 
                    case 'P':
                        return `${childMarkdown}${node.parentElement === container ? '\n\n' : ''}`;
                    case 'FIGURE': {
                        const img = node.querySelector('img');
                        const figcaption = node.querySelector('figcaption');
                        const alt = figcaption ? figcaption.textContent : (img ? img.alt : '');
                        const src = img ? img.src : '';
                        return `![${alt}](${src})\n\n`;
                    }
                    case 'BLOCKQUOTE': {
                        const lines = childMarkdown.trim().split('\n');
                        return lines.map(line => `> ${line}`).join('\n') + '\n\n';
                    }
                    case 'PRE': {
                        const codeNode = node.querySelector('code');
                        const langMatch = codeNode ? codeNode.className.match(/language-(\w+)/) : null;
                        const lang = langMatch ? langMatch[1] : '';
                        const code = codeNode ? codeNode.innerText : node.innerText;
                        return `\`\`\`${lang}\n${code}\n\`\`\`\n\n`;
                    }
                    case 'TABLE': {
                        let tableMd = '';
                        const headRows = Array.from(node.querySelectorAll('thead tr'));
                        const bodyRows = Array.from(node.querySelectorAll('tbody tr'));
                        const colCount = headRows.length > 0 ? headRows[0].cells.length : (bodyRows.length > 0 ? bodyRows[0].cells.length : 0);

                        if (colCount > 0 && headRows.length > 0) {
                            const headers = Array.from(headRows[0].cells).map(cell => cell.textContent.trim());
                            tableMd += `| ${headers.join(' | ')} |\n`;
                            const alignments = JSON.parse(node.dataset.alignments || '[]');
                            const separator = Array.from({ length: colCount }).map((_, i) => {
                                const align = alignments[i] || '';
                                if (align === 'center') return ':---:';
                                if (align === 'right') return '---:';
                                if (align === 'left') return ':---';
                                return '---';
                            });
                            tableMd += `| ${separator.join(' | ')} |\n`;
                        }

                        bodyRows.forEach(row => {
                            const cells = Array.from(row.cells).map(cell => cell.textContent.trim());
                            tableMd += `| ${cells.join(' | ')} |\n`;
                        });
                        return tableMd ? tableMd + '\n' : '';
                    }
                    case 'UL':
                    case 'OL': {
                        const level = (listState.level || 0) + 1;
                        let counter = node.tagName === 'OL' ? (parseInt(node.getAttribute('start'), 10) || 1) : 0;
                        return Array.from(node.children).map(li => {
                            const md = convertNode(li, { type: node.tagName, level, counter });
                            if (counter > 0) counter++;
                            return md;
                        }).join('');
                    }
                    case 'LI': {
                        const indent = '    '.repeat((listState.level || 1) - 1);
                        let prefix;
                        if (node.classList.contains('checklist-item')) {
                            const isChecked = node.classList.contains('checked');
                            prefix = `${indent}- [${isChecked ? 'x' : ' '}] `;
                        } else if (listState.type === 'OL') {
                            prefix = `${indent}${listState.counter}. `;
                        } else {
                            prefix = `${indent}- `;
                        }
                        let content = '', nestedListContent = '';
                        node.childNodes.forEach(child => {
                            if (child.nodeName === 'UL' || child.nodeName === 'OL') {
                                nestedListContent += convertNode(child, listState);
                            } else {
                                content += convertNode(child, listState);
                            }
                        });
                        return `${prefix}${content.trim()}\n${nestedListContent}`;
                    }
                    default: return childMarkdown;
                }
            }

            let markdown = convertNode(container);
            markdown = markdown.split('\n').map(line => line.trimEnd()).join('\n');
            return markdown.trim();
        }

        editor.addEventListener('copy', (e) => {
            const markdown = getMarkdownFromSelection();
            if (markdown) {
                e.preventDefault();
                e.clipboardData.setData('text/plain', markdown);
            }
        });

        editor.addEventListener('focusout', () => {
            if (activeRawNode) {
                renderActiveNode();
            }
        });
    </script>
</body>
</html>